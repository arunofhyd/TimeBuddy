<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TimeBuddy</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter for a modern look -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for Inter font and general body */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* Soft light gray background */
            color: #2d3748; /* Darker text for readability */
        }

        /* Style for calendar grid cells */
        .calendar-day-cell {
            min-height: 100px; /* Ensure cells have enough height */
            display: flex;
            flex-direction: column;
            align-items: center; /* Center content horizontally */
            justify-content: flex-start;
            padding: 12px; /* Increased padding */
            cursor: pointer;
            border-radius: 8px; /* More rounded corners */
            transition: all 0.2s ease-in-out; /* Smoother transitions */
            box-shadow: 0 1px 3px rgba(0,0,0,0.05); /* Subtle shadow */
        }
        .calendar-day-cell.current-month {
            background-color: #ffffff; /* White for current month days */
            border: 1px solid #e2e8f0; /* Light border */
        }
        .calendar-day-cell.other-month {
            background-color: #f8fafc; /* Very light for other months */
            color: #a0aec0; /* Faded text for other months */
            border: 1px solid #edf2f7;
        }
        .calendar-day-cell.has-activity {
            border: 2px solid #3b82f6; /* Updated Blue */
            box-shadow: 0 4px 6px rgba(0,0,0,0.1); /* More prominent shadow */
        }
        .calendar-day-cell.selected-day {
            background-color: #eff6ff; /* Light blue highlight for selected day */
            border: 2px solid #3b82f6; /* Updated Blue */
            transform: translateY(-2px); /* Slight lift */
            box-shadow: 0 6px 10px rgba(0,0,0,0.15);
        }
        .calendar-day-cell:hover {
            background-color: #e2e8f0; /* Hover effect */
            transform: translateY(-1px); /* Slight lift on hover */
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .day-number {
            font-weight: 600; /* Semi-bold */
            font-size: 1.2em; /* Slightly larger */
            margin-bottom: 6px;
            color: #2d3748;
        }
        .calendar-day-cell.other-month .day-number {
            color: #a0aec0; /* Faded for other months */
        }
        .calendar-day-cell.is-sunday .day-number {
            color: #ef4444; /* Red color for Sunday numbers */
        }
        .calendar-day-cell.is-today .day-number {
            color: #3b82f6;
            font-weight: 700;
        }

        .activity-indicator {
            width: 10px; /* Slightly larger dot */
            height: 10px;
            background-color: #3b82f6; /* Updated Blue */
            border-radius: 50%;
            margin-top: 6px;
        }

        /* Custom button styles for a more polished look */
        .btn-primary {
            background-color: #3b82f6; /* Updated Blue (Vibrant) */
            color: #ffffff;
            border: 1px solid #3b82f6; /* Updated Blue */
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .btn-primary:hover {
            background-color: #2563eb; /* Darker vibrant blue on hover */
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        .btn-secondary {
            background-color: #e2e8f0; /* Light gray */
            color: #4a5568;
            border: 1px solid #e2e8f0;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .btn-secondary:hover {
            background-color: #cbd5e0; /* Darker gray on hover */
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .btn-danger {
            background-color: #e53e3e; /* Red */
            color: #ffffff;
            border: 1px solid #e53e3e;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .btn-danger:hover {
            background-color: #c53030; /* Darker red on hover */
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        /* Icon button specific styles */
        .icon-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem; /* Smaller padding for icons */
            border-radius: 0.375rem; /* Tailwind rounded-md */
            transition: all 0.2s ease-in-out;
            border: 1px solid transparent; /* Default transparent border */
            color: #4a5568; /* Default icon color */
        }
        .icon-btn:hover {
            background-color: #e2e8f0; /* Light gray on hover */
            border-color: #cbd5e0; /* Subtle border on hover */
        }
        .icon-btn.edit:hover, .icon-btn.save:hover {
            color: #3b82f6; /* Updated Blue */
        }
        .icon-btn.delete:hover {
            color: #e53e3e; /* Red on hover */
        }

        /* Message popup styles */
        #message-display {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        #message-display.show {
            opacity: 1;
            visibility: visible;
        }

        /* Modal backdrop blur */
        .modal-backdrop {
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        /* Inline editing specific styles */
        .activity-text-editable, .time-editable {
            min-height: 24px; /* Ensure a minimum height for editing */
            outline: none; /* Remove default outline */
            border-bottom: 1px dashed #a0aec0; /* Subtle dashed border when editable */
            padding-bottom: 2px;
            transition: border-color 0.2s ease-in-out, background-color 0.2s ease-in-out;
            cursor: text; /* Indicate it's editable */
        }
        .activity-text-editable:focus, .time-editable:focus {
            border-bottom: 1px solid #3b82f6; /* Updated Blue */
            background-color: #f0f8ff; /* Very light blue background on focus */
        }
        .activity-text-editable.editing, .time-editable.editing {
            background-color: #f0f8ff; /* Light blue background when editing */
        }

        /* Drag and Drop styles */
        .daily-activity-table-body tr.dragging {
            opacity: 0.5;
            background-color: #e0f2fe; /* Light blue background for dragged item */
            border: 1px dashed #3b82f6; /* Updated Blue */
        }
        .daily-activity-table-body tr.drag-over-top {
            border-top: 2px solid #3b82f6; /* Updated Blue */
        }
        .daily-activity-table-body tr.drag-over-bottom {
            border-bottom: 2px solid #3b82f6; /* Updated Blue */
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 767px) {
            #calendar-view {
                gap: 0.25rem; /* Reduced gap for smaller screens (gap-1) */
            }
            .calendar-day-cell {
                min-height: 70px; /* Flexible height instead of a fixed square */
                padding: 8px; /* More vertical space for content */
                justify-content: flex-start; /* Align content to the top */
            }
            .day-number {
                font-size: 0.875em; /* Smaller font for smaller cells */
                margin-bottom: 2px;
            }
            .activity-indicator {
                width: 6px;
                height: 6px;
                margin-top: 2px;
            }
            /* Adjust padding for table cells on small screens */
            .daily-activity-table-body td {
                padding-left: 10px;
                padding-right: 10px;
            }
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center py-8 px-4">

    <div class="w-full max-w-4xl bg-white rounded-xl border border-gray-200 shadow-2xl p-6 md:p-8">
        <div class="flex justify-between items-center mb-6">
            <h1 class="text-4xl font-extrabold text-gray-800 tracking-tight text-center w-full">
                TimeBuddy
            </h1>
        </div>

        <!-- Message Display -->
        <div id="message-display" class="bg-blue-100 border border-blue-400 text-blue-700 px-4 py-3 rounded-lg shadow-md" role="alert">
            <span id="message-text" class="block sm:inline font-medium"></span>
        </div>

        <!-- Navigation Section -->
        <div class="flex flex-col space-y-4 mb-8 w-full">
            <!-- View Toggles Row -->
            <div class="flex space-x-4 w-full">
                <!-- Month View Button -->
                <button id="month-view-btn" class="w-1/2 px-5 py-3 text-base font-semibold btn-primary rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                    Month View
                </button>

                <!-- Day View Button -->
                <button id="day-view-btn" class="w-1/2 px-5 py-3 text-base font-semibold btn-secondary rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                    Day View
                </button>
            </div>

            <!-- Period Navigation (Prev/Next/Display) -->
            <div class="flex items-center justify-between w-full">
                <button id="prev-btn" class="btn-primary rounded-full flex items-center justify-center w-12 h-12 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M15 19l-7-7 7-7"></path></svg>
                </button>
                <h2 id="current-period-display" class="text-xl font-bold text-gray-800 text-center mx-2 cursor-pointer hover:text-blue-600 transition-colors duration-200">
                    <!-- JS will insert: July 2025 -->
                </h2>
                <button id="next-btn" class="btn-primary rounded-full flex items-center justify-center w-12 h-12 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M9 5l7 7-7 7"></path></svg>
                </button>
            </div>

            <!-- Today Button -->
            <button id="today-btn" class="w-full px-5 py-3 text-base font-bold text-gray-700 bg-white border-2 border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 hover:bg-gray-50">
                Today
            </button>
            
            <input type="file" id="upload-csv-input" accept=".csv" class="hidden">
        </div>


        <!-- Main Content Area -->
        <div id="main-content-area" class="w-full">
            <!-- Calendar View -->
            <div id="calendar-view" class="grid grid-cols-7 gap-3">
                <!-- Day names header -->
                <div class="py-3 text-center text-sm font-semibold text-red-500 bg-gray-100 border border-gray-200 rounded-lg">Sun</div>
                <div class="py-3 text-center text-sm font-semibold text-gray-700 bg-gray-100 border-gray-200 rounded-lg">Mon</div>
                <div class="py-3 text-center text-sm font-semibold text-gray-700 bg-gray-100 border-gray-200 rounded-lg">Tue</div>
                <div class="py-3 text-center text-sm font-semibold text-gray-700 bg-gray-100 border-gray-200 rounded-lg">Wed</div>
                <div class="py-3 text-center text-sm font-semibold text-gray-700 bg-gray-100 border-gray-200 rounded-lg">Thu</div>
                <div class="py-3 text-center text-sm font-semibold text-gray-700 bg-gray-100 border-gray-200 rounded-lg">Fri</div>
                <div class="py-3 text-center text-sm font-semibold text-gray-700 bg-gray-100 border-gray-200 rounded-lg">Sat</div>
                <!-- Calendar days will be generated here by JS -->
            </div>

            <!-- Daily View -->
            <div id="daily-view" class="hidden">
                <button id="add-new-slot-btn" class="px-6 py-3 mb-6 btn-primary rounded-lg w-full focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                    Add New Slot
                    <svg class="inline-block w-5 h-5 ml-2 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>
                </button>
                <table class="min-w-full bg-white border border-gray-200 rounded-lg overflow-hidden shadow-md">
                    <thead class="bg-gray-50">
                        <tr>
                            <th class="py-3 px-4 text-left text-sm font-semibold text-gray-700 uppercase tracking-wider border-b border-gray-200 w-1/6">Time</th>
                            <th class="py-3 px-4 text-left text-sm font-semibold text-gray-700 uppercase tracking-wider border-b border-gray-200 w-4/6">Activity</th>
                            <th class="py-3 px-4 text-center text-sm font-semibold text-gray-700 uppercase tracking-wider border-b border-gray-200 w-1/6">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="daily-activity-table-body" class="divide-y divide-gray-200">
                        <!-- Daily activities will be inserted here by JS -->
                    </tbody>
                </table>
                <p id="no-daily-activities-message" class="text-center text-gray-500 italic mt-6 hidden">No activities recorded for this day.</p>
            </div>

            <!-- Data Actions Section -->
            <div class="mt-8 pt-6 border-t border-gray-200 flex flex-col md:flex-row gap-4">
                <button id="upload-csv-btn" class="w-full md:w-1/2 px-5 py-3 text-base font-semibold btn-secondary rounded-lg flex items-center justify-center focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                    <svg class="w-5 h-5 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0l-4 4m4-4v12"></path></svg>
                    <span>Upload Data</span>
                </button>
                <button id="download-csv-btn" class="w-full md:w-1/2 px-5 py-3 text-base font-semibold btn-primary rounded-lg flex items-center justify-center focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                     <svg class="w-5 h-5 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                    <span>Download Data</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Hourly Prompt Modal (Used only for hourly prompt) -->
    <div id="hourly-prompt-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50 modal-backdrop">
        <div class="bg-white rounded-xl border border-gray-200 shadow-2xl p-6 md:p-8 w-full max-w-md transform transition-all duration-300 scale-100">
            <h2 class="text-2xl font-bold text-gray-900 mb-6 text-center">
                Time to Log Activity!
            </h2>
            <p class="text-lg text-gray-700 mb-4 text-center">
                What did you do in the last hour?
            </p>
            <textarea id="hourly-activity-input" class="w-full p-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none resize-y min-h-[100px]"></textarea>
            <div class="flex justify-end mt-6 space-x-3">
                <button id="close-hourly-prompt-modal-btn" class="px-5 py-2 btn-secondary rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                    Close
                </button>
                <button id="save-hourly-activity-btn" class="px-5 py-2 btn-primary rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                    Save
                </button>
            </div>
        </div>
    </div>

    <!-- Month Picker Modal -->
    <div id="month-picker-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50 modal-backdrop">
        <div class="bg-white rounded-xl border border-gray-200 shadow-2xl p-6 md:p-8 w-full max-w-md transform transition-all duration-300 scale-100">
            <div class="flex justify-between items-center mb-6">
                <button id="prev-year-btn" class="p-2 btn-secondary rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2" aria-label="Previous Year">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 19l-7-7 7-7m8 14l-7-7 7-7"></path></svg>
                </button>
                <h3 id="picker-year-display" class="text-2xl font-semibold text-gray-800">2023</h3>
                <button id="next-year-btn" class="p-2 btn-secondary rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2" aria-label="Next Year">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7M6 5l7 7-7 7"></path></svg>
                </button>
            </div>
            <div id="month-grid" class="grid grid-cols-3 gap-3">
                <!-- Month buttons will be generated here -->
            </div>
            <div class="flex justify-end mt-6">
                <button id="close-month-picker-btn" class="px-5 py-2 btn-secondary rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                    Close
                </button>
            </div>
        </div>
    </div>

    <!-- Footer Attribution -->
    <div class="mt-10 text-center text-gray-500 text-xs opacity-80">
        Made with ❤️ by Arun Thomas
    </div>

    <script>
        // Global state variables
        let activityData = {}; // Stores all activities from local storage
        let currentMonth = new Date(); // Tracks the month being viewed in calendar
        let selectedDate = new Date(); // Tracks the currently selected day for daily view
        let currentPromptHour = ''; // The hour for the current prompt (e.g., "08:00")
        let lastPromptedHour = null; // To prevent multiple prompts in the same hour
        let lastPromptedDate = null; // To reset prompted hour daily
        let currentView = 'month'; // 'month' or 'day'
        let editingInlineTimeKey = null; // Stores the time key of the entry being edited inline
        let draggedItem = null; // Stores the row being dragged

        // Month Picker Modal specific state
        let pickerYear = new Date().getFullYear();

        // DOM Elements
        const messageDisplay = document.getElementById('message-display');
        const messageText = document.getElementById('message-text');
        const currentPeriodDisplay = document.getElementById('current-period-display');

        // View buttons
        const monthViewBtn = document.getElementById('month-view-btn');
        const dayViewBtn = document.getElementById('day-view-btn');

        // Navigation buttons (Prev/Next)
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const todayBtn = document.getElementById('today-btn'); // Today button

        // Content containers
        const calendarView = document.getElementById('calendar-view');
        const dailyView = document.getElementById('daily-view');

        // Daily view specific elements
        const addNewSlotBtn = document.getElementById('add-new-slot-btn'); // Renamed ID
        const dailyActivityTableBody = document.getElementById('daily-activity-table-body');
        const noDailyActivitiesMessage = document.getElementById('no-daily-activities-message');

        // Hourly Prompt Modal elements (now separate from general add/edit)
        const hourlyPromptModal = document.getElementById('hourly-prompt-modal');
        const hourlyActivityInput = document.getElementById('hourly-activity-input');
        const saveHourlyActivityBtn = document.getElementById('save-hourly-activity-btn');
        const closeHourlyPromptModalBtn = document.getElementById('close-hourly-prompt-modal-btn');

        // CSV buttons
        const downloadCsvBtn = document.getElementById('download-csv-btn');
        const uploadCsvBtn = document.getElementById('upload-csv-btn');
        const uploadCsvInput = document.getElementById('upload-csv-input');


        // Month Picker Modal elements
        const monthPickerModal = document.getElementById('month-picker-modal');
        const prevYearBtn = document.getElementById('prev-year-btn');
        const nextYearBtn = document.getElementById('next-year-btn');
        const pickerYearDisplay = document.getElementById('picker-year-display');
        const monthGrid = document.getElementById('month-grid');
        const closeMonthPickerBtn = document.getElementById('close-month-picker-btn');


        // --- Helper Functions ---

        // Displays a temporary message to the user
        function showMessage(msg, type = 'info') {
            messageText.textContent = msg;
            messageDisplay.classList.remove('bg-blue-100', 'border-blue-400', 'text-blue-700', 'bg-red-100', 'border-red-400', 'text-red-700');
            if (type === 'error') {
                messageDisplay.classList.add('bg-red-100', 'border-red-400', 'text-red-700');
            } else {
                messageDisplay.classList.add('bg-blue-100', 'border-blue-400', 'text-blue-700');
            }
            messageDisplay.classList.add('show'); // Make it visible
            
            clearTimeout(messageDisplay.dataset.timeoutId); // Clear any existing timeout
            const timeoutId = setTimeout(() => {
                messageDisplay.classList.remove('show'); // Hide after 2 seconds
            }, 2000);
            messageDisplay.dataset.timeoutId = timeoutId; // Store timeout ID
        }

        // Loads all activity data from local storage
        function loadActivityDataFromLocalStorage() {
            try {
                const storedData = localStorage.getItem('activityTrackerData');
                const parsedData = storedData ? JSON.parse(storedData) : {};

                // Convert old data format (string activity) to new (object with text and order)
                // And ensure 'order' property exists for all activities
                for (const dateKey in parsedData) {
                    for (const timeKey in parsedData[dateKey]) {
                        if (typeof parsedData[dateKey][timeKey] === 'string') {
                            parsedData[dateKey][timeKey] = {
                                text: parsedData[dateKey][timeKey],
                                order: 0 // Default order
                            };
                        }
                        // Ensure order exists for all, assign if missing
                        if (parsedData[dateKey][timeKey].order === undefined) {
                             parsedData[dateKey][timeKey].order = 0;
                        }
                    }
                }
                return parsedData;
            }
            catch (error) {
                console.error("Error loading data from local storage:", error);
                showMessage("Error: Could not load data from local storage.", 'error');
                return {};
            }
        }

        // Saves all activity data to local storage
        function saveActivityDataToLocalStorage(data) {
            try {
                localStorage.setItem('activityTrackerData', JSON.stringify(data));
            }
            catch (error) {
                console.error("Error saving data to local storage:", error);
                showMessage("Error: Could not save data to local storage.", 'error');
            }
        }

        // Formats a date object into YYYY-MM-DD string
        function getYYYYMMDD(date) {
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Formats a date string (YYYY-MM-DD) for display
        function formatDateForDisplay(dateString) {
            const date = new Date(dateString + 'T00:00:00'); // Add T00:00:00 to avoid timezone issues
            return date.toLocaleDateString('en-US', { weekday: 'short', year: 'numeric', month: 'long', day: 'numeric' });
        }

        // Helper to parse date string like "Thursday, July 25, 2025" back to YYYY-MM-DD
        function parseDisplayDateToYYYYMMDD(displayDateStr) {
            // Remove weekday and just parse "Month Day, Year"
            const parts = displayDateStr.split(', ');
            if (parts.length < 3) return null; // Invalid format
            const monthDayYear = `${parts[1]} ${parts[2]}`;
            const date = new Date(monthDayYear);
            if (isNaN(date.getTime())) return null; // Invalid date
            return getYYYYMMDD(date);
        }

        // --- Calendar View Functions ---

        function renderCalendar() {
            // Clear previous calendar days (keep day names header)
            while (calendarView.children.length > 7) {
                calendarView.removeChild(calendarView.lastChild);
            }

            const year = currentMonth.getFullYear();
            const month = currentMonth.getMonth(); // 0-indexed
            const firstDayOfMonth = new Date(year, month, 1);
            const lastDayOfMonth = new Date(year, month + 1, 0);
            const numDaysInMonth = lastDayOfMonth.getDate();
            const firstDayOfWeek = firstDayOfMonth.getDay(); // 0 for Sunday, 1 for Monday

            const allStoredData = loadActivityDataFromLocalStorage();
            const today = new Date(); // Get today's date for highlighting

            // Add empty cells for days before the 1st of the month
            for (let i = 0; i < firstDayOfWeek; i++) {
                const emptyCell = document.createElement('div');
                emptyCell.classList.add('calendar-day-cell', 'other-month');
                calendarView.appendChild(emptyCell);
            }

            // Add cells for each day of the month
            for (let day = 1; day <= numDaysInMonth; day++) {
                const date = new Date(year, month, day);
                const dateKey = getYYYYMMDD(date);
                
                // Check if the day has any non-empty activities
                let hasActivity = false;
                if (allStoredData[dateKey]) {
                    // Filter out the _userCleared flag before checking for actual activities
                    const actualActivities = Object.keys(allStoredData[dateKey]).filter(key => key !== '_userCleared');
                    for (const timeKey of actualActivities) {
                        if (allStoredData[dateKey][timeKey].text && allStoredData[dateKey][timeKey].text.trim() !== '') {
                            hasActivity = true;
                            break;
                        }
                    }
                }

                const dayCell = document.createElement('div');
                dayCell.classList.add('calendar-day-cell', 'current-month');
                if (date.getDay() === 0) { // Check if it's Sunday
                    dayCell.classList.add('is-sunday'); // Add class for Sunday styling
                }
                if (hasActivity) {
                    dayCell.classList.add('has-activity');
                }
                if (getYYYYMMDD(date) === getYYYYMMDD(selectedDate) && currentView === 'day') {
                    dayCell.classList.add('selected-day');
                }
                // Highlight today's date
                if (getYYYYMMDD(date) === getYYYYMMDD(today)) {
                    dayCell.classList.add('is-today');
                }

                const dayNumberSpan = document.createElement('div');
                dayNumberSpan.classList.add('day-number');
                dayNumberSpan.textContent = day;
                dayCell.appendChild(dayNumberSpan);

                if (hasActivity) {
                    dayCell.innerHTML += `<div class="activity-indicator"></div>`;
                }

                dayCell.dataset.date = dateKey; // Store date string for easy access
                dayCell.addEventListener('click', () => {
                    selectedDate = date; // Update selectedDate to the clicked day
                    currentView = 'day'; // Switch to day view
                    updateView();
                });
                calendarView.appendChild(dayCell);
            }

            // Add empty cells for days after the last day of the month to complete the last week
            const totalCells = firstDayOfWeek + numDaysInMonth;
            const remainingCells = (7 - (totalCells % 7)) % 7;
            for (let i = 0; i < remainingCells; i++) {
                const emptyCell = document.createElement('div');
                emptyCell.classList.add('calendar-day-cell', 'other-month');
                calendarView.appendChild(emptyCell);
            }
        }

        // --- Daily View Functions ---

        function renderDailyActivities() {
            dailyActivityTableBody.innerHTML = ''; // Clear existing rows
            const dateKey = getYYYYMMDD(selectedDate);
            const allStoredData = loadActivityDataFromLocalStorage();
            let dailyActivitiesMap = allStoredData[dateKey] || {}; // Ensure it's an object

            // --- Logic for default 8 AM - 6 PM rows ---
            // Only populate default hours if the day's data is completely empty AND it hasn't been user-cleared.
            // Also, do NOT populate on Sundays (date.getDay() === 0)
            const isUserCleared = dailyActivitiesMap._userCleared === true;
            const hasActualActivities = Object.keys(dailyActivitiesMap).filter(key => key !== '_userCleared').length > 0;
            const isSunday = selectedDate.getDay() === 0;

            if (!hasActualActivities && !isUserCleared && !isSunday) {
                // Populate defaults only if truly empty, not explicitly cleared, and not Sunday
                for (let h = 8; h <= 17; h++) { // Loop up to 17 for 17:00-18:00 slot
                    const timeKey = `${h.toString().padStart(2, '0')}:00-${(h + 1).toString().padStart(2, '0')}:00`; // Time range
                    dailyActivitiesMap[timeKey] = { text: "", order: h - 8 }; // Assign order based on hour
                }
                allStoredData[dateKey] = dailyActivitiesMap;
                saveActivityDataToLocalStorage(allStoredData);
            } else if (!hasActualActivities && isUserCleared) {
                // If it's user-cleared and has no actual activities, ensure the map is truly empty
                dailyActivitiesMap = {}; // Clear all entries including _userCleared
                allStoredData[dateKey] = {}; // Save empty map to localStorage
                saveActivityDataToLocalStorage(allStoredData);
            }
            // --- End of default population logic ---


            // Filter out the _userCleared flag before processing activities for display
            let dailyActivitiesArray = Object.keys(dailyActivitiesMap)
                .filter(timeKey => timeKey !== '_userCleared')
                .map(timeKey => ({
                    time: timeKey,
                    text: dailyActivitiesMap[timeKey].text,
                    order: dailyActivitiesMap[timeKey].order
                }));

            // Sort by order
            dailyActivitiesArray.sort((a, b) => a.order - b.order);

            // Re-assign orders based on sorted visual position to maintain clean order values
            dailyActivitiesArray.forEach((activity, index) => {
                activity.order = index;
            });

            // Convert back to map for saving (including the _userCleared flag if present)
            let updatedDailyActivitiesMap = {};
            dailyActivitiesArray.forEach(activity => {
                updatedDailyActivitiesMap[activity.time] = {
                    text: activity.text,
                    order: activity.order
                };
            });
            if (isUserCleared) { // Re-add the flag if it was present
                updatedDailyActivitiesMap._userCleared = true;
            }

            // Only save if actual changes occurred (important to avoid infinite loops with onstorage event if we had one)
            if (JSON.stringify(dailyActivitiesMap) !== JSON.stringify(updatedDailyActivitiesMap)) {
                allStoredData[dateKey] = updatedDailyActivitiesMap;
                saveActivityDataToLocalStorage(allStoredData);
            }

            // Reset inline editing state when re-rendering
            editingInlineTimeKey = null;

            if (dailyActivitiesArray.length > 0) {
                noDailyActivitiesMessage.classList.add('hidden');
                dailyActivitiesArray.forEach(activity => {
                    const timeKey = activity.time;
                    const text = activity.text;
                    const row = document.createElement('tr');
                    row.classList.add('hover:bg-gray-100', 'transition-colors', 'duration-150');
                    row.setAttribute('draggable', 'true'); // Make rows draggable
                    row.dataset.time = timeKey; // Store timeKey for drag-drop and actions

                    // Time cell - contenteditable
                    const timeCell = document.createElement('td');
                    timeCell.classList.add('py-3', 'px-4', 'whitespace-nowrap', 'text-sm', 'text-gray-900', 'border-b', 'border-gray-100', 'cursor-text', 'time-editable');
                    timeCell.textContent = timeKey;
                    timeCell.dataset.time = timeKey;
                    timeCell.contentEditable = "true";

                    // Activity text cell - contenteditable
                    const activityTextCell = document.createElement('td');
                    activityTextCell.classList.add('py-3', 'px-4', 'text-sm', 'text-gray-900', 'border-b', 'border-gray-100');
                    const activityTextDiv = document.createElement('div');
                    activityTextDiv.classList.add('activity-text-editable');
                    activityTextDiv.textContent = text;
                    activityTextDiv.dataset.time = timeKey;
                    activityTextDiv.contentEditable = "true";
                    activityTextCell.appendChild(activityTextDiv);

                    // Actions cell - will dynamically change icons
                    const actionsCell = document.createElement('td');
                    actionsCell.classList.add('py-3', 'px-4', 'text-sm', 'border-b', 'border-gray-100', 'flex', 'space-x-1', 'justify-center', 'items-center');
                    actionsCell.dataset.time = timeKey;

                    // Initial state: pencil and bin icons
                    actionsCell.innerHTML = `
                        <button class="icon-btn edit-btn" aria-label="Edit" data-time="${timeKey}">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg>
                        </button>
                        <button class="icon-btn delete-btn" aria-label="Delete" data-time="${timeKey}">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                        </button>
                    `;

                    row.appendChild(timeCell);
                    row.appendChild(activityTextCell);
                    row.appendChild(actionsCell);

                    dailyActivityTableBody.appendChild(row);
                });

                // Attach event listeners for inline editing and actions
                attachDailyActivityEventListeners();

                // Attach drag and drop listeners
                attachDragAndDropListeners();

            } else {
                noDailyActivitiesMessage.classList.remove('hidden');
            }
        }

        // Centralized function to attach event listeners for inline editing and actions
        function attachDailyActivityEventListeners() {
            document.querySelectorAll('.activity-text-editable, .time-editable').forEach(element => {
                element.removeEventListener('click', handleInlineEditClick); // Prevent double attachment
                element.addEventListener('click', handleInlineEditClick);
                element.removeEventListener('blur', handleInlineEditBlur);
                element.addEventListener('blur', handleInlineEditBlur);
                element.removeEventListener('keydown', handleInlineEditKeydown);
                element.addEventListener('keydown', handleInlineEditKeydown);
            });

            document.querySelectorAll('.edit-btn').forEach(button => {
                button.removeEventListener('click', handleEditButtonClick);
                button.addEventListener('click', handleEditButtonClick);
            });

            document.querySelectorAll('.delete-btn').forEach(button => {
                button.removeEventListener('click', handleDeleteButtonClick);
                button.addEventListener('click', handleDeleteButtonClick);
            });
        }

        function handleInlineEditClick(event) {
            const targetElement = event.currentTarget;
            const time = targetElement.dataset.time;

            // If another item is being edited, save it first
            if (editingInlineTimeKey && editingInlineTimeKey !== time) {
                const previousEditableElement = document.querySelector(`[data-time="${editingInlineTimeKey}"].activity-text-editable`) || document.querySelector(`[data-time="${editingInlineTimeKey}"].time-editable`);
                if (previousEditableElement) {
                    previousEditableElement.blur(); // Trigger blur to save
                }
            }

            targetElement.contentEditable = "true";
            targetElement.focus();
            targetElement.classList.add('editing'); // Visual cue for editing
            editingInlineTimeKey = time; // Set current inline editing state

            // Change icons to save/delete for this row
            const actionsCell = targetElement.closest('tr').querySelector('td:last-child');
            actionsCell.innerHTML = `
                <button class="icon-btn save-btn" aria-label="Save" data-time="${time}">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>
                </button>
                <button class="icon-btn delete-btn" aria-label="Delete" data-time="${time}">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                </button>
            `;
            attachInlineActionListeners(time); // Re-attach listeners for new buttons
        }

        function handleInlineEditBlur(event) {
            const targetElement = event.currentTarget;
            const time = targetElement.dataset.time;
            // Only save if this is the currently active inline edit
            if (editingInlineTimeKey === time) {
                if (targetElement.classList.contains('time-editable')) {
                    saveInlineTime(time, targetElement.textContent.trim());
                } else {
                    saveInlineActivityText(time, targetElement.textContent.trim());
                }
            }
            targetElement.classList.remove('editing'); // Remove visual cue
        }

        function handleInlineEditKeydown(event) {
            if (event.key === 'Enter') {
                event.preventDefault(); // Prevent new line
                event.currentTarget.blur(); // Trigger blur to save
            }
        }

        function handleEditButtonClick(event) {
            const time = event.currentTarget.dataset.time;
            const activityDiv = document.querySelector(`.activity-text-editable[data-time="${time}"]`);
            if (activityDiv) {
                activityDiv.click(); // Simulate click to enable inline edit
            }
        }

        function handleDeleteButtonClick(event) {
            const time = event.currentTarget.dataset.time;
            deleteActivity(getYYYYMMDD(selectedDate), time);
        }

        // Attaches listeners for the dynamically created save/delete buttons during inline edit
        function attachInlineActionListeners(timeKey) {
            const actionsCell = document.querySelector(`td[data-time="${timeKey}"]`);
            if (!actionsCell) return;

            actionsCell.querySelector('.save-btn').addEventListener('click', (event) => {
                const time = event.currentTarget.dataset.time;
                const activityDiv = document.querySelector(`.activity-text-editable[data-time="${time}"]`);
                const timeDiv = document.querySelector(`.time-editable[data-time="${time}"]`);

                // Blur both to trigger save
                if (activityDiv) activityDiv.blur();
                if (timeDiv) timeDiv.blur();
            });

            actionsCell.querySelector('.delete-btn').addEventListener('click', (event) => {
                const time = event.currentTarget.dataset.time;
                deleteActivity(getYYYYMMDD(selectedDate), time);
            });
        }

        // --- Drag and Drop Functions ---
        function attachDragAndDropListeners() {
            const rows = dailyActivityTableBody.querySelectorAll('tr');
            rows.forEach(row => {
                row.removeEventListener('dragstart', handleDragStart);
                row.addEventListener('dragstart', handleDragStart);
                row.removeEventListener('dragover', handleDragOver);
                row.addEventListener('dragover', handleDragOver);
                row.removeEventListener('dragleave', handleDragLeave);
                row.addEventListener('dragleave', handleDragLeave);
                row.removeEventListener('drop', handleDrop);
                row.addEventListener('drop', handleDrop);
                row.removeEventListener('dragend', handleDragEnd);
                row.addEventListener('dragend', handleDragEnd);
            });
        }

        function handleDragStart(e) {
            draggedItem = e.target.closest('tr');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', draggedItem.dataset.time); // Store timeKey
            draggedItem.classList.add('dragging');
        }

        function handleDragOver(e) {
            e.preventDefault(); // Necessary to allow dropping
            const targetRow = e.target.closest('tr');
            if (targetRow && targetRow !== draggedItem) {
                // Remove existing drag-over indicators
                dailyActivityTableBody.querySelectorAll('.drag-over-top, .drag-over-bottom').forEach(row => {
                    row.classList.remove('drag-over-top', 'drag-over-bottom');
                });

                const rect = targetRow.getBoundingClientRect();
                const offsetY = e.clientY - rect.top;

                if (offsetY < rect.height / 2) {
                    targetRow.classList.add('drag-over-top');
                } else {
                    targetRow.classList.add('drag-over-bottom');
                }
            }
        }

        function handleDragLeave(e) {
            e.target.closest('tr').classList.remove('drag-over-top', 'drag-over-bottom');
        }

        function handleDrop(e) {
            e.preventDefault();
            const targetRow = e.target.closest('tr');
            if (!targetRow || targetRow === draggedItem) return;

            const rect = targetRow.getBoundingClientRect();
            const offsetY = e.clientY - rect.top;

            // Remove drag-over indicators
            dailyActivityTableBody.querySelectorAll('.drag-over-top, .drag-over-bottom').forEach(row => {
                row.classList.remove('drag-over-top', 'drag-over-bottom');
            });

            if (offsetY < rect.height / 2) {
                // Drop above targetRow
                dailyActivityTableBody.insertBefore(draggedItem, targetRow);
            } else {
                // Drop below targetRow
                dailyActivityTableBody.insertBefore(draggedItem, targetRow.nextSibling);
            }

            updateActivityOrderInLocalStorage();
        }

        function handleDragEnd(e) {
            draggedItem.classList.remove('dragging');
            draggedItem = null;
            // Ensure no lingering drag-over classes
            dailyActivityTableBody.querySelectorAll('.drag-over-top, .drag-over-bottom').forEach(row => {
                row.classList.remove('drag-over-top', 'drag-over-bottom');
            });
        }

        function updateActivityOrderInLocalStorage() {
            const dateKey = getYYYYMMDD(selectedDate);
            const allStoredData = loadActivityDataFromLocalStorage();
            let dailyActivitiesMap = allStoredData[dateKey] || {};

            const orderedTimeKeys = Array.from(dailyActivityTableBody.children).map(row => row.dataset.time);

            let newDailyActivitiesMap = {};
            orderedTimeKeys.forEach((timeKey, index) => {
                if (dailyActivitiesMap[timeKey]) {
                    newDailyActivitiesMap[timeKey] = {
                        text: dailyActivitiesMap[timeKey].text,
                        order: index // Assign new order based on visual position
                    };
                }
            });

            // Preserve _userCleared flag if it exists
            if (dailyActivitiesMap._userCleared) {
                newDailyActivitiesMap._userCleared = true;
            }

            allStoredData[dateKey] = newDailyActivitiesMap;
            saveActivityDataToLocalStorage(allStoredData);
            showMessage("Activities reordered successfully!", 'success');
            // Re-render to ensure consistency, though not strictly needed for visual
            // update after drag-drop as DOM is already reordered.
            // This ensures internal data model is fully consistent.
            renderDailyActivities();
        }


        // --- View Management ---

        function updateView() {
            // Update button states
            if (currentView === 'month') {
                monthViewBtn.classList.remove('btn-secondary');
                monthViewBtn.classList.add('btn-primary');
                dayViewBtn.classList.remove('btn-primary');
                dayViewBtn.classList.add('btn-secondary');

                calendarView.classList.remove('hidden');
                dailyView.classList.add('hidden');
                currentPeriodDisplay.textContent = currentMonth.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                currentPeriodDisplay.classList.add('cursor-pointer'); // Make clickable for month picker
                renderCalendar();
            } else { // currentView === 'day'
                dayViewBtn.classList.remove('btn-secondary');
                dayViewBtn.classList.add('btn-primary');
                monthViewBtn.classList.remove('btn-primary');
                monthViewBtn.classList.add('btn-secondary');

                dailyView.classList.remove('hidden');
                calendarView.classList.add('hidden');
                currentPeriodDisplay.textContent = formatDateForDisplay(getYYYYMMDD(selectedDate));
                currentPeriodDisplay.classList.remove('cursor-pointer'); // Not clickable in day view
                renderDailyActivities();
            }
        }

        // --- Core Logic ---

        // Checks time hourly and prompts user
        function checkTimeAndPrompt() {
            const now = new Date();
            const dayOfWeek = now.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
            const hour = now.getHours();
            const minutes = now.getMinutes();
            const currentDateStr = getYYYYMMDD(now);

            // Reset lastPromptedHour at the start of a new day
            if (lastPromptedDate !== currentDateStr) {
                lastPromptedHour = null;
                lastPromptedDate = currentDateStr;
            }

            // Check if it's a workday (Monday-Friday) and within working hours (8 AM - 6 PM) and exactly on the hour
            if (dayOfWeek >= 1 && dayOfWeek <= 5 && hour >= 8 && hour <= 18 && minutes === 0) {
                // Prevent multiple prompts for the same hour
                if (lastPromptedHour !== hour) {
                    currentPromptHour = `${hour.toString().padStart(2, '0')}:00`;
                    // Display native browser notification
                    showNativeNotification(currentPromptHour);
                    // Open the specific hourly prompt modal
                    hourlyActivityInput.value = ''; // Clear previous input
                    hourlyPromptModal.classList.remove('hidden');
                    lastPromptedHour = hour; // Mark this hour as prompted
                }
            }
        }

        // Function to show native browser notification
        function showNativeNotification(promptHour) {
            if (!("Notification" in window)) {
                console.warn("This browser does not support desktop notification");
            } else if (Notification.permission === "granted") {
                new Notification("TimeBuddy - Log Activity!", {
                    body: `What did you do in the last hour?`, 
                    silent: true // No sound
                });
            } else if (Notification.permission !== "denied") {
                Notification.requestPermission().then(function (permission) {
                    if (permission === "granted") {
                        new Notification("TimeBuddy - Log Activity!", {
                            body: `What did you do in the last hour?`,
                            silent: true // No sound
                        });
                    }
                });
            }
        }

        // Handles saving activity from the hourly prompt modal
        function saveHourlyActivity() {
            const dateKey = getYYYYMMDD(new Date()); // Always current day for hourly prompt
            const activityText = hourlyActivityInput.value.trim();

            if (!activityText) { // Activity text is the only required field from the user
                showMessage("Activity cannot be empty.", 'error');
                return;
            }

            const allStoredData = loadActivityDataFromLocalStorage();
            if (!allStoredData[dateKey]) {
                allStoredData[dateKey] = {};
            }

            // The prompt appears AT the hour mark (e.g., 13:00), asking about the PREVIOUS hour (12:00-13:00)
            const promptEndHourInt = parseInt(currentPromptHour.split(':')[0]); // e.g., 13
            const activityStartHourInt = promptEndHourInt - 1; // e.g., 12
            
            const targetTimeRangeKey = `${activityStartHourInt.toString().padStart(2, '0')}:00-${promptEndHourInt.toString().padStart(2, '0')}:00`;

            // If a matching time range key is found, update it
            if (allStoredData[dateKey][targetTimeRangeKey]) {
                allStoredData[dateKey][targetTimeRangeKey].text = activityText;
            } else {
                let maxOrder = -1;
                if (Object.keys(allStoredData[dateKey]).filter(key => key !== '_userCleared').length > 0) {
                    maxOrder = Math.max(...Object.values(allStoredData[dateKey]).filter(item => typeof item === 'object' && item !== null && item.order !== undefined).map(item => item.order));
                }
                allStoredData[dateKey][targetTimeRangeKey] = { // Use the full range as the key
                    text: activityText,
                    order: maxOrder + 1
                };
            }

            // Remove the _userCleared flag if an activity is saved/updated
            if (allStoredData[dateKey]._userCleared) {
                delete allStoredData[dateKey]._userCleared;
            }

            saveActivityDataToLocalStorage(allStoredData);

            showMessage("Activity saved successfully!", 'success');
            hourlyPromptModal.classList.add('hidden');
            // Re-render the current view if it's the current day
            if (dateKey === getYYYYMMDD(selectedDate)) {
                updateView();
            }
        }

        // Handles saving activity text from inline edit
        function saveInlineActivityText(timeKey, newActivityText) {
            const dateKey = getYYYYMMDD(selectedDate);
            const allStoredData = loadActivityDataFromLocalStorage();

            if (!allStoredData[dateKey]) {
                allStoredData[dateKey] = {};
            }
            // Ensure the activity object exists and update its text
            if (allStoredData[dateKey][timeKey]) {
                allStoredData[dateKey][timeKey].text = newActivityText;
            } else {
                let maxOrder = -1;
                if (Object.keys(allStoredData[dateKey]).filter(key => key !== '_userCleared').length > 0) {
                     maxOrder = Math.max(...Object.values(allStoredData[dateKey]).filter(item => typeof item === 'object' && item !== null && item.order !== undefined).map(item => item.order));
                }
                allStoredData[dateKey][timeKey] = { text: newActivityText, order: maxOrder + 1 };
            }

            // Remove the _userCleared flag if an activity is saved/updated
            if (allStoredData[dateKey]._userCleared) {
                delete allStoredData[dateKey]._userCleared;
            }

            saveActivityDataToLocalStorage(allStoredData);

            showMessage("Activity updated successfully!", 'success');
            editingInlineTimeKey = null; // Reset inline editing state
            updateView(); // Re-render to revert icons
        }

        // Handles saving time from inline edit
        function saveInlineTime(oldTimeKey, newTimeKey) {
            const dateKey = getYYYYMMDD(selectedDate);
            const allStoredData = loadActivityDataFromLocalStorage();

            if (newTimeKey.trim() === '') {
                showMessage("Time cannot be empty.", 'error');
                const timeElement = document.querySelector(`.time-editable[data-time="${oldTimeKey}"]`);
                if (timeElement) {
                    timeElement.textContent = oldTimeKey;
                }
                editingInlineTimeKey = null;
                updateView();
                return;
            }

            if (!allStoredData[dateKey]) {
                allStoredData[dateKey] = {};
            }

            const existingEntryWithNewTimeKey = Object.keys(allStoredData[dateKey]).find(key => 
                key === newTimeKey && key !== oldTimeKey
            );

            if (existingEntryWithNewTimeKey) {
                showMessage(`An activity already exists with the time "${newTimeKey}" for this day.`, 'error');
                const timeElement = document.querySelector(`.time-editable[data-time="${oldTimeKey}"]`);
                if (timeElement) {
                    timeElement.textContent = oldTimeKey; // Revert display
                }
                editingInlineTimeKey = null;
                updateView();
                return;
            }

            const activityEntry = allStoredData[dateKey][oldTimeKey];
            if (activityEntry) {
                const activityText = activityEntry.text;
                const activityOrder = activityEntry.order;

                delete allStoredData[dateKey][oldTimeKey];

                allStoredData[dateKey][newTimeKey] = {
                    text: activityText,
                    order: activityOrder
                };
            } else {
                 showMessage("Error: Could not find activity to move.", 'error');
            }

            if (allStoredData[dateKey]._userCleared) {
                delete allStoredData[dateKey]._userCleared;
            }

            saveActivityDataToLocalStorage(allStoredData);

            showMessage("Time updated successfully!", 'success');
            editingInlineTimeKey = null; // Reset inline editing state
            updateView(); // Re-render to sort and revert icons
        }

        // Deletes an activity entry
        function deleteActivity(dateKey, timeKey) {
            const allStoredData = loadActivityDataFromLocalStorage();
            if (allStoredData[dateKey] && allStoredData[dateKey][timeKey]) {
                delete allStoredData[dateKey][timeKey];
                
                const hasActualActivities = Object.keys(allStoredData[dateKey]).filter(key => key !== '_userCleared').length > 0;

                if (!hasActualActivities) {
                    allStoredData[dateKey] = { _userCleared: true };
                }
                
                saveActivityDataToLocalStorage(allStoredData);
                showMessage("Activity deleted successfully!", 'success');
                updateView(); // Re-render the current view
            }
        }

        // Function to download data as CSV
        function downloadCSV() {
            const allStoredData = loadActivityDataFromLocalStorage();
            const yearMonth = `${currentMonth.getFullYear()}-${(currentMonth.getMonth() + 1).toString().padStart(2, '0')}`;

            let csvContent = "data:text/csv;charset=utf-8,";
            csvContent += "Date,Time,Activity\n"; // CSV Header

            const monthlyActivities = Object.keys(allStoredData)
                .filter(dateKey => dateKey.startsWith(yearMonth));

            if (monthlyActivities.length === 0) {
                showMessage("No activities to export for this month.", 'info');
                return;
            }

            let activitiesToExport = [];
            monthlyActivities.forEach(dateKey => {
                const dailyEntries = Object.keys(allStoredData[dateKey])
                    .filter(timeKey => timeKey !== '_userCleared') // Filter out the flag
                    .map(timeKey => ({
                        date: dateKey,
                        time: timeKey,
                        text: allStoredData[dateKey][timeKey].text,
                        order: allStoredData[dateKey][timeKey].order
                    }));
                activitiesToExport = activitiesToExport.concat(dailyEntries);
            });

            // Sort by date, then by order
            activitiesToExport.sort((a, b) => {
                const dateComparison = a.date.localeCompare(b.date);
                if (dateComparison !== 0) return dateComparison;
                return a.order - b.order;
            });


            activitiesToExport.forEach(entry => {
                // Escape double quotes by replacing each with two double quotes
                const activity = entry.text.replace(/"/g, '""');
                csvContent += `"${formatDateForDisplay(entry.date)}","${entry.time}","${activity}"\n`;
            });

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", `TimeBuddy_${yearMonth}.csv`);
            document.body.appendChild(link); // Required for Firefox
            link.click(); // Simulate click
            document.body.removeChild(link); // Clean up
            showMessage(`Exported activities for ${yearMonth} to CSV!`, 'success');
        }

        // --- CSV Upload Functions ---
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const csvContent = e.target.result;
                parseAndImportCSV(csvContent);
            };
            reader.onerror = () => {
                showMessage("Error reading file.", 'error');
            };
            reader.readAsText(file);
        }

        function parseAndImportCSV(csvContent) {
            const lines = csvContent.split('\n').filter(line => line.trim() !== '');
            if (lines.length === 0) {
                showMessage("CSV file is empty.", 'error');
                return;
            }

            const headers = lines[0].split(',').map(h => h.trim().replace(/^"|"$/g, ''));
            if (headers[0] !== "Date" || headers[1] !== "Time" || headers[2] !== "Activity") {
                showMessage("Invalid CSV format. Expected headers: Date,Time,Activity", 'error');
                return;
            }

            const importedData = {};
            let currentMaxOrder = -1; // To assign orders sequentially within a day

            for (let i = 1; i < lines.length; i++) {
                const row = parseCsvLine(lines[i]); // Robust CSV line parsing
                if (row.length < 3) continue; // Skip malformed rows

                const displayDateStr = row[0];
                const time = row[1];
                const activityText = row[2];

                const dateKey = parseDisplayDateToYYYYMMDD(displayDateStr);

                if (!dateKey) {
                    console.warn(`Skipping row due to invalid date format: ${displayDateStr}`);
                    continue;
                }

                if (!importedData[dateKey]) {
                    importedData[dateKey] = {};
                    currentMaxOrder = -1; // Reset order for new day
                }

                let orderToAssign = importedData[dateKey][time] ? importedData[dateKey][time].order : currentMaxOrder + 1;
                
                importedData[dateKey][time] = {
                    text: activityText,
                    order: orderToAssign
                };
                currentMaxOrder = Math.max(currentMaxOrder, orderToAssign);
            }

            const allExistingData = loadActivityDataFromLocalStorage();
            let mergedData = { ...allExistingData }; // Start with existing data

            // Merge imported data: overwrite existing, add new
            for (const dateKey in importedData) {
                if (!mergedData[dateKey]) {
                    mergedData[dateKey] = {};
                }
                // Merge activities for this day, preserving existing order if timeKey matches
                for (const timeKey in importedData[dateKey]) {
                    mergedData[dateKey][timeKey] = importedData[dateKey][timeKey];
                }
                // After merging, re-sort and re-assign orders for the entire day to ensure consistency
                let dayActivitiesArray = Object.keys(mergedData[dateKey])
                    .filter(key => key !== '_userCleared')
                    .map(timeKey => ({
                        time: timeKey,
                        text: mergedData[dateKey][timeKey].text,
                        order: mergedData[dateKey][timeKey].order
                    }));
                dayActivitiesArray.sort((a, b) => a.order - b.order); // Sort by current order
                
                let reorderedDayMap = {};
                dayActivitiesArray.forEach((activity, index) => {
                    reorderedDayMap[activity.time] = {
                        text: activity.text,
                        order: index
                    };
                });
                // Preserve _userCleared flag if it was there
                if (mergedData[dateKey]._userCleared) {
                    reorderedDayMap._userCleared = true;
                }
                mergedData[dateKey] = reorderedDayMap;
            }

            saveActivityDataToLocalStorage(mergedData);
            showMessage("CSV data imported successfully!", 'success');
            updateView(); // Re-render the UI
        }

        // Robust CSV line parser (handles commas within quoted fields)
        function parseCsvLine(line) {
            const result = [];
            let inQuote = false;
            let currentField = '';
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuote = !inQuote;
                    // Handle escaped quotes within a field (e.g., "" becomes ")
                    if (inQuote && line[i + 1] === '"') {
                        currentField += '"';
                        i++;
                    }
                } else if (char === ',' && !inQuote) {
                    result.push(currentField.trim());
                    currentField = '';
                } else {
                    currentField += char;
                }
            }
            result.push(currentField.trim()); // Push the last field
            return result.map(field => field.replace(/^"|"$/g, '')); // Remove surrounding quotes
        }


        // --- Event Listeners ---

        // View buttons
        monthViewBtn.addEventListener('click', () => {
            currentView = 'month';
            updateView();
        });
        dayViewBtn.addEventListener('click', () => {
            currentView = 'day';
            updateView();
        });

        // Navigation buttons (Prev/Next)
        prevBtn.addEventListener('click', () => {
            if (currentView === 'month') {
                currentMonth.setMonth(currentMonth.getMonth() - 1);
            } else { // currentView === 'day'
                selectedDate.setDate(selectedDate.getDate() - 1);
            }
            updateView();
        });

        nextBtn.addEventListener('click', () => {
            if (currentView === 'month') {
                currentMonth.setMonth(currentMonth.getMonth() + 1);
            } else { // currentView === 'day'
                selectedDate.setDate(selectedDate.getDate() + 1);
            }
            updateView();
        });

        // Today Button
        todayBtn.addEventListener('click', () => {
            const today = new Date();
            selectedDate = today; // Always set selectedDate to today
            currentMonth = new Date(today.getFullYear(), today.getMonth(), 1); // Also update currentMonth for calendar context

            if (currentView === 'day') {
                // If we are already in day view, just jump to today's date
                // The view will remain 'day', and updateView will handle the re-render
                updateView();
            } else {
                // If in month view (or any other state), switch to month view and show today
                currentView = 'month';
                updateView();
            }
        });

        // Current Period Display (Month/Day Text) to open Month Picker
        currentPeriodDisplay.addEventListener('click', () => {
            if (currentView === 'month') { // Only open picker if in month view
                pickerYear = currentMonth.getFullYear(); // Initialize picker to current month's year
                renderMonthPicker();
                monthPickerModal.classList.remove('hidden');
            }
        });

        // Add New Activity button (in daily view)
        addNewSlotBtn.addEventListener('click', () => { // Renamed ID
            const dateKey = getYYYYMMDD(selectedDate);
            const allStoredData = loadActivityDataFromLocalStorage();

            // Find a unique placeholder time starting from 00:00
            let newTimeKey = "00:00";
            let counter = 0;
            // Ensure the new time key is unique for the current day
            while (allStoredData[dateKey] && allStoredData[dateKey][newTimeKey]) {
                newTimeKey = `00:00-${++counter}`;
            }

            if (!allStoredData[dateKey]) {
                allStoredData[dateKey] = {};
            }

            // Assign a high order to new entries to put them at the end
            let maxOrder = -1;
            if (Object.keys(allStoredData[dateKey]).filter(key => key !== '_userCleared').length > 0) {
                 maxOrder = Math.max(...Object.values(allStoredData[dateKey]).filter(item => typeof item === 'object' && item !== null && item.order !== undefined).map(item => item.order));
            }

            allStoredData[dateKey][newTimeKey] = {
                text: "",
                order: maxOrder + 1
            };

            // Remove the _userCleared flag if a new activity is added
            if (allStoredData[dateKey]._userCleared) {
                delete allStoredData[dateKey]._userCleared;
            }

            saveActivityDataToLocalStorage(allStoredData);

            updateView(); // Re-render to show the new row

            // After re-rendering, find the new elements and focus the activity field
            setTimeout(() => { // Use setTimeout to ensure DOM is updated
                const newActivityDiv = document.querySelector(`.activity-text-editable[data-time="${newTimeKey}"]`);
                if (newActivityDiv) {
                    newActivityDiv.click(); // Simulate click to enable inline edit and show save/delete icons
                }
            }, 0);
        });

        // Hourly Prompt Modal buttons
        saveHourlyActivityBtn.addEventListener('click', saveHourlyActivity);
        closeHourlyPromptModalBtn.addEventListener('click', () => {
            hourlyPromptModal.classList.add('hidden');
        });

        // Download CSV button
        downloadCsvBtn.addEventListener('click', downloadCSV);

        // Upload CSV button
        uploadCsvBtn.addEventListener('click', () => {
            uploadCsvInput.click(); // Trigger the hidden file input
        });
        uploadCsvInput.addEventListener('change', handleFileUpload); // Listen for file selection

        // Month Picker Modal Event Listeners
        prevYearBtn.addEventListener('click', () => {
            pickerYear--;
            renderMonthPicker();
        });
        nextYearBtn.addEventListener('click', () => {
            pickerYear++;
            renderMonthPicker();
        });
        closeMonthPickerBtn.addEventListener('click', () => {
            monthPickerModal.classList.add('hidden');
        });


        // --- Month Picker Functions ---
        function renderMonthPicker() {
            monthGrid.innerHTML = ''; // Clear existing months
            pickerYearDisplay.textContent = pickerYear;

            const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

            monthNames.forEach((name, index) => {
                const monthButton = document.createElement('button');
                monthButton.classList.add('px-4', 'py-3', 'rounded-lg', 'font-medium', 'text-gray-800', 'bg-gray-100', 'hover:bg-blue-100', 'hover:text-blue-700', 'transition-colors', 'duration-200', 'focus:outline-none', 'focus:ring-2', 'focus:ring-blue-500', 'focus:ring-offset-2');
                monthButton.textContent = name;
                monthButton.dataset.monthIndex = index; // Store 0-11 month index

                // Highlight current month in picker
                if (pickerYear === currentMonth.getFullYear() && index === currentMonth.getMonth()) {
                    monthButton.classList.remove('bg-gray-100', 'text-gray-800');
                    monthButton.classList.add('bg-blue-500', 'text-white');
                }

                monthButton.addEventListener('click', () => {
                    currentMonth = new Date(pickerYear, index, 1); // Set to 1st of selected month
                    selectedDate = new Date(pickerYear, index, 1); // Also set selected date to 1st of month
                    currentView = 'month'; // Always switch to month view after picking
                    updateView();
                    monthPickerModal.classList.add('hidden'); // Close modal
                });
                monthGrid.appendChild(monthButton);
            });
        }

        // --- Initialization ---
        window.onload = function() {
            // Set selectedDate to today's date initially for day view
            selectedDate = new Date();
            // Start with month view by default
            currentView = 'month';
            updateView(); // Initial render of the calendar/day view

            // Set up hourly check
            setInterval(checkTimeAndPrompt, 60 * 1000); // Every minute
            checkTimeAndPrompt(); // Initial check on load
        };

    </script>
</body>
</html>
